{"name":"Zcm","tagline":"Zero Communications and Marshalling","body":"# ZCM: Zero Communications and Marshalling\r\n\r\nZCM is a micro-framework for message-passing and data-marshalling, designed originally\r\nfor robotics systems where high-bandwidth and low-latency are critical and the variance in\r\ncompute platforms is large.\r\n\r\nZCM is a publish/subscribe message-passing system with automatic message type-checking and\r\nserialization. It provides bindings for a variety of programming languages, and generates\r\nlanguage-specific message serialization routines. Using a ZCM message feels natural\r\nin each language.\r\n\r\nZCM is transport-agnostic. There is no required built-in transport. Every transport is\r\nfirst-class. This is achieved by defining strict blocking and non-blocking transport APIs. As\r\nlong as a transport implementation conforms to this API, it should work flawlessly with ZCM.\r\nThis design allows ZCM to work well on anything from a high-end posix-based compute cluster\r\nwith thousands of nodes to a low-end real-time embedded-system with no operating system.\r\n\r\nZCM is a derivation of the LCM project created in 2006 by the MIT DARPA Urban Challenge\r\nteam. The core message-type system, publish/subscribe APIs, and basic tools are ported\r\ndirectly from LCM and remain about 95% compatible. While there are a handful of subtle\r\ndifferences between the two, the core distinguishing feature is ZCM's transport\r\nagnosticism. LCM is designed completely around UDP Multicast. This transport makes a lot\r\nof sense for LAN connected compute clusters (such the original 2006 MIT DGC Vechicle).\r\nHowever, there are many other applications that are interesting targets for ZCM messaging.\r\nThese include: local system messaging (IPC), multi-threaded messaging (in-process),\r\nembedded-system peripherals (UART, I2C, etc), and web applications (Web Sockets).\r\nBy refusing to make hard assumptions about the transport layer, ZCM opens the door\r\nto a wide set of use-cases that were neither possible nor practical with LCM.\r\n\r\nTo learn more about what ZCM tries to be, and its guiding principles, check out the\r\n[Project Philosphy](docs/philosophy.md).\r\n\r\nTo dive, in and see some examples, check out the [Tutorial](docs/tutorial.md).\r\n\r\nIf you have previously used LCM, check out [From LCM to ZCM](docs/lcm_to_zcm.md).\r\n\r\nTo learn how you can contribute to this project, check out [Contributing](docs/contributing.md)\r\n\r\n## Quick Links\r\n - [Tutorial](docs/tutorial.md)\r\n - [From LCM to ZCM](docs/lcm_to_zcm.md)\r\n - [ZCM Type System](docs/zcmtypesys.md)\r\n - [Transport Layer](docs/transports.md)\r\n - [Embedded Applications](docs/embedded.md)\r\n - Web Applications (coming soon)\r\n - [Continuous Integration](https://github.com/ZeroCM/zcm/actions/workflows/build.yml)\r\n - [Dependencies & Building](docs/building.md)\r\n - [Project Philosphy](docs/philosophy.md)\r\n - [Contributing](docs/contributing.md)\r\n\r\n## Features\r\n - Type-safe and version-safe message serialization\r\n - A useful suite of tools for logging, log-playback, and real-time message inspection (spy)\r\n - A wide set of optionally built-in transports including UDP Multicast, IPC, In-Process, Serial, and ZeroMQ\r\n - A well-defined interface for building custom transports\r\n - Strong support for embedded applications. The core embedded code is restricted to C89.\r\n - Only one true dependency: A modern C++11 compiler for the non-embedded code.\r\n\r\n## Supported platforms and languages\r\n\r\n - Platforms:\r\n  - GNU/Linux\r\n  - Web browsers supporting the Websocket API\r\n  - Any C89 capable embedded system\r\n\r\n - Languages\r\n  - C89 and greater\r\n  - C++\r\n  - Java\r\n  - MATLAB (using Java)\r\n  - NodeJS and Client-side Javascript\r\n\r\n## Roadmap\r\n - Platform Support\r\n   - Windows\r\n   - OS X\r\n   - Any POSIX-1.2001 system (e.g., Cygwin, Solaris, BSD, etc.)\r\n - Consider porting the rest of the LCM languages\r\n   - Python\r\n   - C#\r\n   - Lua\r\n - Explore alternative messaging paradigms using ZCM Types (e.g. those found in ZeroMQ)\r\n - Break from the original LCM APIs to improve API consistency\r\n   - Goal for v2.0\r\n   - v1.0 will **always** strive for API compatibility\r\n\r\n## Subtle differences to LCM\r\n\r\nZCM is approximately 95% API compatible with LCM. Porting existing Unix-based LCM\r\nprograms to ZCM is very easy in many cases. A quick `sed -i 's/lcm/zcm/g'` works for\r\nmost applications. ZCM uses the same binary-compatible formats for UDP Multicast, Logging,\r\nand ZCMType encodings. Thus LCM and ZCM applications can communicate flawlessly. This\r\nallows LCM users to gradually migrate to ZCM.\r\n\r\n### Known incompatibilities:\r\n - `zcm_get_fileno()` is not supported\r\n - `zcm_handle_timeout()` is not supported\r\n - Any applications using GLib via LCM may have build errors\r\n   - ZCM does *not* depend on GLib\r\n - ZCMType drops support for the LCMType-style enums\r\n","google":"UA-73394372-1","note":"Don't delete this file! It's used internally to help with page regeneration."}
