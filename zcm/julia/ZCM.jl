module ZCM

# AbstractZcmType functions
export encode,
       decode,
       getHash,
       fieldnames,
       constfieldnames
# Zcm functions
export Zcm,
       good,
       strerrno,
       subscribe,
       unsubscribe,
       publish,
       pause,
       resume,
       flush,
       start,
       stop,
       handle,
       handle_nonblock,
       set_queue_size,
       write_topology,
       read_bits,
       write_bits,
       LogEvent,
       LogFile,
       read_next_event,
       read_prev_event,
       read_event_at_offset,
       write_event

import Base: flush,
             fieldnames,
             unsafe_convert

abstract type AbstractZcmType end


# Function stubs. Autogenerated ZCM types will extend these functions
# with new methods.
function encode(msg::AbstractZcmType) end
function decode(::Type{AbstractZcmType}, data::Vector{UInt8}) end
function getHash(::Type{AbstractZcmType}) end
function _get_hash_recursive(::Type{AbstractZcmType}, parents::Array{String}) end
function _encode_one(msg::AbstractZcmType, buf) end
function _decode_one(::Type{AbstractZcmType}, buf) end
function fieldnames(::Type{AbstractZcmType}) end
function constfieldnames(::Type{AbstractZcmType}) end
# TODO: would be nice to have getEncodedSize() and _getEncodedSizeNoHash()


# Note: Julia requires that the memory layout of the C structs is consistent
#       between their definitions in zcm headers and this file

# C ptr types for types that we don't need the internals of
module Native

mutable struct Zcm
end

mutable struct Sub
end

struct  RecvBuf
    recv_utime ::Int64
    zcm        ::Ptr{Cvoid}
    # TODO: This makes the assumption that char in C is 8 bits, which is not required to be true
    data       ::Ptr{UInt8}
    data_size  ::UInt32
end

mutable struct EventLog
end

mutable struct EventLogEvent
    eventnum  ::Int64
    timestamp ::Int64
    chanlen   ::Int32
    datalen   ::Int32
    channel   ::Ptr{UInt8}
    data      ::Ptr{UInt8}
end

end

using .Native: RecvBuf

struct SubscriptionHandler{F}
    jl_handler::F
    msgtype
    additional_args::Tuple
end

"""
The Subscription type contains the Julia handler and also all of the various C pointers
"""
struct Subscription{F}
    jl_handler::SubscriptionHandler{F}
    c_handler::Union{Ptr{Cvoid}, Base.CFunction}
    native_sub::Ptr{Native.Sub}
end

mutable struct Zcm
    zcm::Ptr{Native.Zcm}
    subscriptions::Vector{Subscription}

    function Zcm(url::AbstractString = "")
        pointer = ccall(("zcm_create", "libzcm"), Ptr{Native.Zcm}, (Cstring,), url);
        instance = new(pointer, Subscription[])

        finalizer(destroy, instance)

        return instance
    end
end

function destroy(zcm::Zcm)
    if zcm.zcm != C_NULL
        ccall(("zcm_destroy", "libzcm"), Cvoid,
              (Ptr{Native.Zcm},), zcm)
        zcm.zcm = C_NULL
    end
end

# Defines the conversion when we pass this to a C function expecting a pointer
unsafe_convert(::Type{Ptr{Native.Zcm}}, zcm::Zcm) = zcm.zcm

function good(zcm::Zcm)
    zcm.zcm != C_NULL
end

function strerrno(err::Int)
    val = ccall(("zcm_strerrno", "libzcm"), Cstring, (Cint,), Cint(err))
    if (val == C_NULL)
        return "unable to get strerrno"
    else
        return unsafe_string(val)
    end
end

function make_handler_wrapper(::Type{T}) where T <: SubscriptionHandler
    function handler_wrapper(rbuf::Native.RecvBuf, channelbytes::Cstring,
                             subptr::Ptr{Cvoid})

        println("entering handler")
        channel = unsafe_string(channelbytes)
        msgdata = unsafe_wrap(Vector{UInt8}, rbuf.data, rbuf.data_size)

        println("deref sub")
        s = (unsafe_pointer_to_objref(subptr)::Ref{T})[]
        println("$(s.msgtype)")
        println("$(s.additional_args)")
        println("$(s.jl_handler)")

        if s.msgtype == Nothing
            s.jl_handler(rbuf, channel, msgdata, s.additional_args...)
        else
            d = decode(s.msgtype, msgdata)
            s.jl_handler(rbuf, channel, d, s.additional_args...)
        end

        println("done with handler")

        return nothing
    end
    return handler_wrapper
end

"""
    subscribe(zcm::Zcm, channel::AbstractString, handler, msgtype, additional_args...)

Adds a subscription using ZCM object `zcm` on the given channel. The `handler`
must be a function or callable object, and will be called with:

    if msgtype = Nothing
        handler(rbuf::RecvBuf, channel::String, msgdata::Vector{UInt8})
    else
        handler(rbuf::RecvBuf, channel::String, msg::msgtype)

If additional arguments are supplied to `subscribe()` after the handler,
then they will also be passed to the handler each time it is called. So:

    subscribe(zcm, channel, handler, msgType, X, Y, Z)

will cause `handler()` to be invoked with:

    handler(rbuf, channel, msg, X, Y, Z)
"""
function subscribe(zcm::Zcm, channel::AbstractString,
                   handler, msgtype=Nothing,
                   additional_args...)

    handler = SubscriptionHandler(handler, msgtype, additional_args)
    wrapper = make_handler_wrapper(typeof(handler))
    # RRR: this is incompatible on some architectures (including arm)
    c_handler = @cfunction($wrapper, Cvoid, (Ref{Native.RecvBuf}, Cstring, Ptr{Cvoid}))
    csub = Ptr{Native.Sub}(C_NULL)
    while (true)
        csub = ccall(("zcm_try_subscribe", "libzcm"), Ptr{Native.Sub},
                     (Ptr{Native.Zcm}, Cstring, Ptr{Cvoid}, Ptr{Cvoid}),
                     zcm, channel, c_handler, Ref(handler))
        if (csub == C_NULL)
            yield()
        else
            break
        end
    end
    sub = Subscription(handler, c_handler, csub)
    push!(zcm.subscriptions, sub)
    return sub
end

function unsubscribe(zcm::Zcm, sub::Subscription)
    try_unsub = () -> ccall(("zcm_try_unsubscribe", "libzcm"), Cint,
                            (Ptr{Native.Zcm}, Ptr{Native.Sub}), zcm, sub.native_sub)
    ret = Cint(0)
    while (true)
        ret = try_unsub()
        if (ret == -2)
            yield()
        else
            break
        end
    end
    deleteat!(zcm.subscriptions, findall(s -> s == sub, zcm.subscriptions))
    return ret
end

function publish(zcm::Zcm, channel::AbstractString, data::Vector{UInt8})
    ccall(("zcm_publish", "libzcm"), Cint,
          (Ptr{Native.Zcm}, Cstring, Ptr{Cvoid}, UInt32),
          zcm, convert(String, channel), data, length(data))
end

function publish(zcm::Zcm, channel::AbstractString, msg::AbstractZcmType)
    publish(zcm, channel, encode(msg))
end

function pause(zcm::Zcm)
    ccall(("zcm_pause", "libzcm"), Cvoid, (Ptr{Native.Zcm},), zcm)
end

function resume(zcm::Zcm)
    ccall(("zcm_resume", "libzcm"), Cvoid, (Ptr{Native.Zcm},), zcm)
end

function flush(zcm::Zcm)
    while (true)
        ret = ccall(("zcm_try_flush", "libzcm"), Cint, (Ptr{Native.Zcm},), zcm)
        if (ret == Cint(0))
            break
        else
            yield()
        end
    end
end

function start(zcm::Zcm)
    @assert false "Threaded interface was completely broken by Julia 1.6"
    @warn "Threaded interface was partially broken by Julia 1.6 : you cannot put printouts in handlers"
    ccall(("zcm_start", "libzcm"), Cvoid, (Ptr{Native.Zcm},), zcm)
end

function stop(zcm::Zcm)
    @assert false "Threaded interface was completely broken by Julia 1.6"
    while (true)
        ret = ccall(("zcm_try_stop", "libzcm"), Cint, (Ptr{Native.Zcm},), zcm)
        if (ret == Cint(0))
            break
        else
            yield()
        end
    end
end

function handle(zcm::Zcm)
    ccall(("zcm_handle", "libzcm"), Cint, (Ptr{Native.Zcm},), zcm)
end

function handle_nonblock(zcm::Zcm)
    ccall(("zcm_handle_nonblock", "libzcm"), Cint, (Ptr{Native.Zcm},), zcm)
end

function set_queue_size(zcm::Zcm, num::Integer)
    sz = UInt32(num)
    while (true)
        ret = ccall(("zcm_try_set_queue_size", "libzcm"), Cint,
                    (Ptr{Native.Zcm}, UInt32), zcm, sz)
        if (ret == Cint(0))
            break
        else
            yield()
        end
    end
end

function write_topology(zcm::Zcm, name::AbstractString)
    ccall(("zcm_write_topology", "libzcm"), Cint,
          (Ptr{Native.Zcm}, Cstring),
          zcm, convert(String, name))
end

function read_bits(T::Type, buf::IOBuffer, numbits::Int, offset_bit::Int, signExtend::Bool)
    ret = T(0)
    bits_left = numbits
    while (bits_left > 0)
        available_bits = 8 - offset_bit
        bits_covered = available_bits < bits_left ? available_bits : bits_left
        mask = ((1 << bits_covered) - 1) << (8 - bits_covered - offset_bit)
        payload::UInt8 = (peek(buf) & mask) << offset_bit
        shift = 8 - bits_left
        if (bits_left == numbits)
            if (shift < 0)
                if signExtend
                    ret = T(reinterpret(Int8, payload)) << -shift
                else
                    ret = T(payload) << -shift
                end
            else
                if signExtend
                    ret = T(reinterpret(Int8, payload)) >> shift
                else
                    ret = payload >>> shift
                end
            end
        else
            if (shift < 0)
                ret |= T(payload) << -shift
            else
                if T == Int8
                    ret |= reinterpret(Int8, payload >>> shift)
                else
                    ret |= T(payload) >>> shift
                end
            end
        end
        bits_left -= bits_covered
        offset_bit += bits_covered
        if (offset_bit == 8)
            offset_bit = 0
            read(buf, 1)
        end
    end

    return offset_bit, ret
end

function write_bits(buf::IOBuffer, value::Any, numbits::Int, byte_in_progress::UInt8, offset_bit::Int)
    bits_left = numbits;
    while (bits_left > 0)
        mask::UInt64 = (1 << bits_left) - 1;
        shift = offset_bit + bits_left - 8;
        if (shift < 0)
            byte_in_progress |= UInt8((value & mask) << -shift)
            offset_bit += bits_left;
            return byte_in_progress, offset_bit
        end
        byte_in_progress |= UInt8((value & mask) >> shift)
        write(buf, byte_in_progress);
        bits_left = shift;
        offset_bit = 0;
        byte_in_progress = UInt8(0)
    end
    return byte_in_progress, offset_bit
end

mutable struct LogEvent
    # These values only valid for events read from a log
    event   ::Ptr{Native.EventLogEvent}
    num     ::Int64

    # These values valid for user created events or events read from a log
    utime   ::Int64
    channel ::String
    data    ::Array{UInt8}

    # Bookkeeping
    valid   ::Bool

    function LogEvent(channel::AbstractString, msg::AbstractZcmType, utime::Int64)
        instance = new()

        instance.event   = C_NULL
        instance.num     = 0
        instance.utime   = utime
        instance.channel = convert(String, channel)
        instance.data    = encode(msg)
        instance.valid   = true

        finalizer(destroy, instance)

        return instance
    end

    function LogEvent(event::Ptr{Native.EventLogEvent})
        instance = new()
        instance.event = event
        instance.valid = false

        if (event != C_NULL)
            loadedEvent = unsafe_load(event)

            instance.num   = loadedEvent.eventnum
            instance.utime = loadedEvent.timestamp
            if (loadedEvent.channel != C_NULL)
                instance.channel = unsafe_string(loadedEvent.channel, loadedEvent.chanlen)
            else
                instance.channel = ""
            end
            if (loadedEvent.data != C_NULL)
                instance.data    = unsafe_wrap(Array, loadedEvent.data, loadedEvent.datalen)
            else
                instance.data    = []
            end

            instance.valid = true
        end

        finalizer(destroy, instance)

        return instance
    end
end

function destroy(event::LogEvent)
    if (event.event != C_NULL)
        ccall(("zcm_eventlog_free_event", "libzcm"), Cvoid,
              (Ptr{Native.EventLogEvent},), event.event)
        event.event = C_NULL
    end
end

function good(event::LogEvent)
    return event.valid
end

mutable struct LogFile
    eventLog::Ptr{Native.EventLog}

    """
    path = the filesystem path of the log
    mode = "w", "r", or "a" for write, read, or append respectively
    """
    function LogFile(path::AbstractString, mode::AbstractString)
        instance = new()
        instance.eventLog = ccall(("zcm_eventlog_create", "libzcm"), Ptr{Native.EventLog},
                                  (Cstring, Cstring), path, mode)

        finalizer(destroy, instance)

        return instance
    end
end

function destroy(log::LogFile)
    if (log.eventLog != C_NULL)
        ccall(("zcm_eventlog_destroy", "libzcm"), Cvoid,
              (Ptr{Native.EventLog},), log.eventLog)
        log.eventLog = C_NULL
    end
end

function good(lf::LogFile)
    return lf.eventLog != C_NULL
end

# TODO: we could actually make all zcmtypes register their hash somewhere and allow the
#       read_event functions to return an actual zcmtype
function read_next_event(lf::LogFile)
    event = ccall(("zcm_eventlog_read_next_event", "libzcm"), Ptr{Native.EventLogEvent},
                  (Ptr{Native.EventLog},), lf.eventLog)
    return LogEvent(event)
end

function read_prev_event(lf::LogFile)
    event = ccall(("zcm_eventlog_read_prev_event", "libzcm"), Ptr{Native.EventLogEvent},
                  (Ptr{Native.EventLog},), lf.eventLog)
    return LogEvent(event)
end

function read_event_at_offset(lf::LogFile, offset::Int64)
    event = ccall(("zcm_eventlog_read_event_at_offset", "libzcm"), Ptr{Native.EventLogEvent},
                  (Ptr{Native.EventLog}, Int64), lf.eventLog, offset)
    return LogEvent(event)
end

function write_event(lf::LogFile, event::LogEvent)
    nativeEvent = Native.EventLogEvent(event.num,
                                       event.utime,
                                       length(event.channel),
                                       length(event.data),
                                       pointer(event.channel),
                                       pointer(event.data))
    return ccall(("zcm_eventlog_write_event", "libzcm"), Cint,
                 (Ptr{Native.EventLog}, Ref{Native.EventLogEvent}),
                 lf.eventLog, nativeEvent)
end

end # module ZCM
